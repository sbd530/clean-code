# 7장 오류 처리

오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 깨끗하고 튼튼한 코드에 한걸음 더 다가가는 단계로 우아하고 고상하게 오류를 처리하는 기법을 알아본다.

## 오류 코드보다 예외를 사용하라

`if else` 문으로 오류 조건을 `else`로 빼내어 처리하면 코드가 복잡해진다.

실행 알고리즘과 오류 처리 알고리즘을 분리하면 가독성이 좋아진다.

```java
public class DeviceController {
    ...

    public void sendShutdown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }
}
```

## Try-Catch-Finally 문부터 작성하라

먼저 강제로 예외를 일이키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 것이 좋다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.

## 미확인 예외를 사용하라

확인된 예외로 메서드에 `throws` 를 추가하면 OCP 를 위반하는 비용을 감수해야 한다. 코드가 바뀌면 하위 함수들의 모든 예외를 알아야하므로 캡슐화 규칙이 깨진다.

중요한 라이브러리를 작성하지 않는 이상 일반적인 어플리케이션에서는 확인된 예외는 의존성이라는 비용이 크게 작용한다.

## 호출자를 고려해 예외 클래스를 정의하라

catch 할 예외가 여러개라면 래퍼 클래스를 만들어서 예외들을 묶을 수 있다. 예외를 새롭게 정의하여 호출될 예외들을 한 곳에 묶어두면 코드가 깔끔해지고 유지보수성이 좋아진다.

실제로 외부 API를 사용할 때는 감싸기 기법이 최선이다.

감싸기 기법을 가용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다.

## null을 반환하지 마라

null을 한번 반환하기 시작하면 호출하는 함수 내부에서 계속해서 null인지를 판단하는 코드를 추가해야 할 것이다.

한번 NPE 에 빠지면 null 가능성이 있는 하위 함수들까지 전부 수색해야 하는 상황이 벌어진다.

`Collections.emptyList()` 등으로 빈 리스트를 반환하는 것도 NPE를 방어하는 방법 중 하나다.

## null을 전달하지 마라

함수 인수로도 null을 전달하면 안된다. 호출 함수가 인수의 null check를 하지 않을 수 있다.

`assert` 문으로 null을 확인하는 방법도 고려해보자.

```java
public double xProjection(Point p1, Point p2) {
    asser p1 != null : "p1 should not be null";
    ...
}
```
